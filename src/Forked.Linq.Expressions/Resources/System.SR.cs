// <auto-generated>
using System.Reflection;

namespace FxResources.System.Linq.Expressions
{
    internal static class SR { }
}
namespace Forked
{
    internal static partial class SR
    {
        private static global::System.Resources.ResourceManager s_resourceManager;
        internal static global::System.Resources.ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new global::System.Resources.ResourceManager(typeof(FxResources.System.Linq.Expressions.SR)));

        /// <summary>reducible nodes must override Expression.Reduce()</summary>
        internal static string ReducibleMustOverrideReduce => GetResourceString("ReducibleMustOverrideReduce", @"reducible nodes must override Expression.Reduce()");
        /// <summary>node cannot reduce to itself or null</summary>
        internal static string MustReduceToDifferent => GetResourceString("MustReduceToDifferent", @"node cannot reduce to itself or null");
        /// <summary>cannot assign from the reduced node type to the original node type</summary>
        internal static string ReducedNotCompatible => GetResourceString("ReducedNotCompatible", @"cannot assign from the reduced node type to the original node type");
        /// <summary>Setter must have parameters.</summary>
        internal static string SetterHasNoParams => GetResourceString("SetterHasNoParams", @"Setter must have parameters.");
        /// <summary>Property cannot have a managed pointer type.</summary>
        internal static string PropertyCannotHaveRefType => GetResourceString("PropertyCannotHaveRefType", @"Property cannot have a managed pointer type.");
        /// <summary>Indexing parameters of getter and setter must match.</summary>
        internal static string IndexesOfSetGetMustMatch => GetResourceString("IndexesOfSetGetMustMatch", @"Indexing parameters of getter and setter must match.");
        /// <summary>Accessor method should not have VarArgs.</summary>
        internal static string AccessorsCannotHaveVarArgs => GetResourceString("AccessorsCannotHaveVarArgs", @"Accessor method should not have VarArgs.");
        /// <summary>Accessor indexes cannot be passed ByRef.</summary>
        internal static string AccessorsCannotHaveByRefArgs => GetResourceString("AccessorsCannotHaveByRefArgs", @"Accessor indexes cannot be passed ByRef.");
        /// <summary>Bounds count cannot be less than 1</summary>
        internal static string BoundsCannotBeLessThanOne => GetResourceString("BoundsCannotBeLessThanOne", @"Bounds count cannot be less than 1");
        /// <summary>Type must not be ByRef</summary>
        internal static string TypeMustNotBeByRef => GetResourceString("TypeMustNotBeByRef", @"Type must not be ByRef");
        /// <summary>Type must not be a pointer type</summary>
        internal static string TypeMustNotBePointer => GetResourceString("TypeMustNotBePointer", @"Type must not be a pointer type");
        /// <summary>Setter should have void type.</summary>
        internal static string SetterMustBeVoid => GetResourceString("SetterMustBeVoid", @"Setter should have void type.");
        /// <summary>Property type must match the value type of getter</summary>
        internal static string PropertyTypeMustMatchGetter => GetResourceString("PropertyTypeMustMatchGetter", @"Property type must match the value type of getter");
        /// <summary>Property type must match the value type of setter</summary>
        internal static string PropertyTypeMustMatchSetter => GetResourceString("PropertyTypeMustMatchSetter", @"Property type must match the value type of setter");
        /// <summary>Both accessors must be static.</summary>
        internal static string BothAccessorsMustBeStatic => GetResourceString("BothAccessorsMustBeStatic", @"Both accessors must be static.");
        /// <summary>Static field requires null instance, non-static field requires non-null instance.</summary>
        internal static string OnlyStaticFieldsHaveNullInstance => GetResourceString("OnlyStaticFieldsHaveNullInstance", @"Static field requires null instance, non-static field requires non-null instance.");
        /// <summary>Static property requires null instance, non-static property requires non-null instance.</summary>
        internal static string OnlyStaticPropertiesHaveNullInstance => GetResourceString("OnlyStaticPropertiesHaveNullInstance", @"Static property requires null instance, non-static property requires non-null instance.");
        /// <summary>Static method requires null instance, non-static method requires non-null instance.</summary>
        internal static string OnlyStaticMethodsHaveNullInstance => GetResourceString("OnlyStaticMethodsHaveNullInstance", @"Static method requires null instance, non-static method requires non-null instance.");
        /// <summary>Property cannot have a void type.</summary>
        internal static string PropertyTypeCannotBeVoid => GetResourceString("PropertyTypeCannotBeVoid", @"Property cannot have a void type.");
        /// <summary>Can only unbox from an object or interface type to a value type.</summary>
        internal static string InvalidUnboxType => GetResourceString("InvalidUnboxType", @"Can only unbox from an object or interface type to a value type.");
        /// <summary>Expression must be writeable</summary>
        internal static string ExpressionMustBeWriteable => GetResourceString("ExpressionMustBeWriteable", @"Expression must be writeable");
        /// <summary>Argument must not have a value type.</summary>
        internal static string ArgumentMustNotHaveValueType => GetResourceString("ArgumentMustNotHaveValueType", @"Argument must not have a value type.");
        /// <summary>must be reducible node</summary>
        internal static string MustBeReducible => GetResourceString("MustBeReducible", @"must be reducible node");
        /// <summary>All test values must have the same type.</summary>
        internal static string AllTestValuesMustHaveSameType => GetResourceString("AllTestValuesMustHaveSameType", @"All test values must have the same type.");
        /// <summary>All case bodies and the default body must have the same type.</summary>
        internal static string AllCaseBodiesMustHaveSameType => GetResourceString("AllCaseBodiesMustHaveSameType", @"All case bodies and the default body must have the same type.");
        /// <summary>Default body must be supplied if case bodies are not System.Void.</summary>
        internal static string DefaultBodyMustBeSupplied => GetResourceString("DefaultBodyMustBeSupplied", @"Default body must be supplied if case bodies are not System.Void.");
        /// <summary>Label type must be System.Void if an expression is not supplied</summary>
        internal static string LabelMustBeVoidOrHaveExpression => GetResourceString("LabelMustBeVoidOrHaveExpression", @"Label type must be System.Void if an expression is not supplied");
        /// <summary>Type must be System.Void for this label argument</summary>
        internal static string LabelTypeMustBeVoid => GetResourceString("LabelTypeMustBeVoid", @"Type must be System.Void for this label argument");
        /// <summary>Quoted expression must be a lambda</summary>
        internal static string QuotedExpressionMustBeLambda => GetResourceString("QuotedExpressionMustBeLambda", @"Quoted expression must be a lambda");
        /// <summary>Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.</summary>
        internal static string VariableMustNotBeByRef => GetResourceString("VariableMustNotBeByRef", @"Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.");
        /// <summary>Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.</summary>
        internal static string DuplicateVariable => GetResourceString("DuplicateVariable", @"Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.");
        /// <summary>Start and End must be well ordered</summary>
        internal static string StartEndMustBeOrdered => GetResourceString("StartEndMustBeOrdered", @"Start and End must be well ordered");
        /// <summary>fault cannot be used with catch or finally clauses</summary>
        internal static string FaultCannotHaveCatchOrFinally => GetResourceString("FaultCannotHaveCatchOrFinally", @"fault cannot be used with catch or finally clauses");
        /// <summary>try must have at least one catch, finally, or fault clause</summary>
        internal static string TryMustHaveCatchFinallyOrFault => GetResourceString("TryMustHaveCatchFinallyOrFault", @"try must have at least one catch, finally, or fault clause");
        /// <summary>Body of catch must have the same type as body of try.</summary>
        internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry => GetResourceString("BodyOfCatchMustHaveSameTypeAsBodyOfTry", @"Body of catch must have the same type as body of try.");
        /// <summary>Extension node must override the property {0}.</summary>
        internal static string ExtensionNodeMustOverrideProperty => GetResourceString("ExtensionNodeMustOverrideProperty", @"Extension node must override the property {0}.");
        /// <summary>User-defined operator method '{0}' must be static.</summary>
        internal static string UserDefinedOperatorMustBeStatic => GetResourceString("UserDefinedOperatorMustBeStatic", @"User-defined operator method '{0}' must be static.");
        /// <summary>User-defined operator method '{0}' must not be void.</summary>
        internal static string UserDefinedOperatorMustNotBeVoid => GetResourceString("UserDefinedOperatorMustNotBeVoid", @"User-defined operator method '{0}' must not be void.");
        /// <summary>No coercion operator is defined between types '{0}' and '{1}'.</summary>
        internal static string CoercionOperatorNotDefined => GetResourceString("CoercionOperatorNotDefined", @"No coercion operator is defined between types '{0}' and '{1}'.");
        /// <summary>The unary operator {0} is not defined for the type '{1}'.</summary>
        internal static string UnaryOperatorNotDefined => GetResourceString("UnaryOperatorNotDefined", @"The unary operator {0} is not defined for the type '{1}'.");
        /// <summary>The binary operator {0} is not defined for the types '{1}' and '{2}'.</summary>
        internal static string BinaryOperatorNotDefined => GetResourceString("BinaryOperatorNotDefined", @"The binary operator {0} is not defined for the types '{1}' and '{2}'.");
        /// <summary>Reference equality is not defined for the types '{0}' and '{1}'.</summary>
        internal static string ReferenceEqualityNotDefined => GetResourceString("ReferenceEqualityNotDefined", @"Reference equality is not defined for the types '{0}' and '{1}'.");
        /// <summary>The operands for operator '{0}' do not match the parameters of method '{1}'.</summary>
        internal static string OperandTypesDoNotMatchParameters => GetResourceString("OperandTypesDoNotMatchParameters", @"The operands for operator '{0}' do not match the parameters of method '{1}'.");
        /// <summary>The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.</summary>
        internal static string OverloadOperatorTypeDoesNotMatchConversionType => GetResourceString("OverloadOperatorTypeDoesNotMatchConversionType", @"The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.");
        /// <summary>Conversion is not supported for arithmetic types without operator overloading.</summary>
        internal static string ConversionIsNotSupportedForArithmeticTypes => GetResourceString("ConversionIsNotSupportedForArithmeticTypes", @"Conversion is not supported for arithmetic types without operator overloading.");
        /// <summary>Argument must be array</summary>
        internal static string ArgumentMustBeArray => GetResourceString("ArgumentMustBeArray", @"Argument must be array");
        /// <summary>Argument must be boolean</summary>
        internal static string ArgumentMustBeBoolean => GetResourceString("ArgumentMustBeBoolean", @"Argument must be boolean");
        /// <summary>The user-defined equality method '{0}' must return a boolean value.</summary>
        internal static string EqualityMustReturnBoolean => GetResourceString("EqualityMustReturnBoolean", @"The user-defined equality method '{0}' must return a boolean value.");
        /// <summary>Argument must be either a FieldInfo or PropertyInfo</summary>
        internal static string ArgumentMustBeFieldInfoOrPropertyInfo => GetResourceString("ArgumentMustBeFieldInfoOrPropertyInfo", @"Argument must be either a FieldInfo or PropertyInfo");
        /// <summary>Argument must be either a FieldInfo, PropertyInfo or MethodInfo</summary>
        internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod => GetResourceString("ArgumentMustBeFieldInfoOrPropertyInfoOrMethod", @"Argument must be either a FieldInfo, PropertyInfo or MethodInfo");
        /// <summary>Argument must be an instance member</summary>
        internal static string ArgumentMustBeInstanceMember => GetResourceString("ArgumentMustBeInstanceMember", @"Argument must be an instance member");
        /// <summary>Argument must be of an integer type</summary>
        internal static string ArgumentMustBeInteger => GetResourceString("ArgumentMustBeInteger", @"Argument must be of an integer type");
        /// <summary>Argument for array index must be of type Int32</summary>
        internal static string ArgumentMustBeArrayIndexType => GetResourceString("ArgumentMustBeArrayIndexType", @"Argument for array index must be of type Int32");
        /// <summary>Argument must be single-dimensional, zero-based array type</summary>
        internal static string ArgumentMustBeSingleDimensionalArrayType => GetResourceString("ArgumentMustBeSingleDimensionalArrayType", @"Argument must be single-dimensional, zero-based array type");
        /// <summary>Argument types do not match</summary>
        internal static string ArgumentTypesMustMatch => GetResourceString("ArgumentTypesMustMatch", @"Argument types do not match");
        /// <summary>Cannot auto initialize elements of value type through property '{0}', use assignment instead</summary>
        internal static string CannotAutoInitializeValueTypeElementThroughProperty => GetResourceString("CannotAutoInitializeValueTypeElementThroughProperty", @"Cannot auto initialize elements of value type through property '{0}', use assignment instead");
        /// <summary>Cannot auto initialize members of value type through property '{0}', use assignment instead</summary>
        internal static string CannotAutoInitializeValueTypeMemberThroughProperty => GetResourceString("CannotAutoInitializeValueTypeMemberThroughProperty", @"Cannot auto initialize members of value type through property '{0}', use assignment instead");
        /// <summary>The type used in TypeAs Expression must be of reference or nullable type, {0} is neither</summary>
        internal static string IncorrectTypeForTypeAs => GetResourceString("IncorrectTypeForTypeAs", @"The type used in TypeAs Expression must be of reference or nullable type, {0} is neither");
        /// <summary>Coalesce used with type that cannot be null</summary>
        internal static string CoalesceUsedOnNonNullType => GetResourceString("CoalesceUsedOnNonNullType", @"Coalesce used with type that cannot be null");
        /// <summary>An expression of type '{0}' cannot be used to initialize an array of type '{1}'</summary>
        internal static string ExpressionTypeCannotInitializeArrayType => GetResourceString("ExpressionTypeCannotInitializeArrayType", @"An expression of type '{0}' cannot be used to initialize an array of type '{1}'");
        /// <summary>Argument type '{0}' does not match the corresponding member type '{1}'</summary>
        internal static string ArgumentTypeDoesNotMatchMember => GetResourceString("ArgumentTypeDoesNotMatchMember", @"Argument type '{0}' does not match the corresponding member type '{1}'");
        /// <summary>The member '{0}' is not declared on type '{1}' being created</summary>
        internal static string ArgumentMemberNotDeclOnType => GetResourceString("ArgumentMemberNotDeclOnType", @"The member '{0}' is not declared on type '{1}' being created");
        /// <summary>Expression of type '{0}' cannot be used for return type '{1}'</summary>
        internal static string ExpressionTypeDoesNotMatchReturn => GetResourceString("ExpressionTypeDoesNotMatchReturn", @"Expression of type '{0}' cannot be used for return type '{1}'");
        /// <summary>Expression of type '{0}' cannot be used for assignment to type '{1}'</summary>
        internal static string ExpressionTypeDoesNotMatchAssignment => GetResourceString("ExpressionTypeDoesNotMatchAssignment", @"Expression of type '{0}' cannot be used for assignment to type '{1}'");
        /// <summary>Expression of type '{0}' cannot be used for label of type '{1}'</summary>
        internal static string ExpressionTypeDoesNotMatchLabel => GetResourceString("ExpressionTypeDoesNotMatchLabel", @"Expression of type '{0}' cannot be used for label of type '{1}'");
        /// <summary>Expression of type '{0}' cannot be invoked</summary>
        internal static string ExpressionTypeNotInvocable => GetResourceString("ExpressionTypeNotInvocable", @"Expression of type '{0}' cannot be invoked");
        /// <summary>Field '{0}' is not defined for type '{1}'</summary>
        internal static string FieldNotDefinedForType => GetResourceString("FieldNotDefinedForType", @"Field '{0}' is not defined for type '{1}'");
        /// <summary>Instance field '{0}' is not defined for type '{1}'</summary>
        internal static string InstanceFieldNotDefinedForType => GetResourceString("InstanceFieldNotDefinedForType", @"Instance field '{0}' is not defined for type '{1}'");
        /// <summary>Field '{0}.{1}' is not defined for type '{2}'</summary>
        internal static string FieldInfoNotDefinedForType => GetResourceString("FieldInfoNotDefinedForType", @"Field '{0}.{1}' is not defined for type '{2}'");
        /// <summary>Incorrect number of indexes</summary>
        internal static string IncorrectNumberOfIndexes => GetResourceString("IncorrectNumberOfIndexes", @"Incorrect number of indexes");
        /// <summary>Incorrect number of parameters supplied for lambda declaration</summary>
        internal static string IncorrectNumberOfLambdaDeclarationParameters => GetResourceString("IncorrectNumberOfLambdaDeclarationParameters", @"Incorrect number of parameters supplied for lambda declaration");
        /// <summary>Incorrect number of members for constructor</summary>
        internal static string IncorrectNumberOfMembersForGivenConstructor => GetResourceString("IncorrectNumberOfMembersForGivenConstructor", @"Incorrect number of members for constructor");
        /// <summary>Incorrect number of arguments for the given members</summary>
        internal static string IncorrectNumberOfArgumentsForMembers => GetResourceString("IncorrectNumberOfArgumentsForMembers", @"Incorrect number of arguments for the given members");
        /// <summary>Lambda type parameter must be derived from System.MulticastDelegate</summary>
        internal static string LambdaTypeMustBeDerivedFromSystemDelegate => GetResourceString("LambdaTypeMustBeDerivedFromSystemDelegate", @"Lambda type parameter must be derived from System.MulticastDelegate");
        /// <summary>Member '{0}' not field or property</summary>
        internal static string MemberNotFieldOrProperty => GetResourceString("MemberNotFieldOrProperty", @"Member '{0}' not field or property");
        /// <summary>Method {0} contains generic parameters</summary>
        internal static string MethodContainsGenericParameters => GetResourceString("MethodContainsGenericParameters", @"Method {0} contains generic parameters");
        /// <summary>Method {0} is a generic method definition</summary>
        internal static string MethodIsGeneric => GetResourceString("MethodIsGeneric", @"Method {0} is a generic method definition");
        /// <summary>The method '{0}.{1}' is not a property accessor</summary>
        internal static string MethodNotPropertyAccessor => GetResourceString("MethodNotPropertyAccessor", @"The method '{0}.{1}' is not a property accessor");
        /// <summary>The property '{0}' has no 'get' accessor</summary>
        internal static string PropertyDoesNotHaveGetter => GetResourceString("PropertyDoesNotHaveGetter", @"The property '{0}' has no 'get' accessor");
        /// <summary>The property '{0}' has no 'set' accessor</summary>
        internal static string PropertyDoesNotHaveSetter => GetResourceString("PropertyDoesNotHaveSetter", @"The property '{0}' has no 'set' accessor");
        /// <summary>The property '{0}' has no 'get' or 'set' accessors</summary>
        internal static string PropertyDoesNotHaveAccessor => GetResourceString("PropertyDoesNotHaveAccessor", @"The property '{0}' has no 'get' or 'set' accessors");
        /// <summary>'{0}' is not a member of type '{1}'</summary>
        internal static string NotAMemberOfType => GetResourceString("NotAMemberOfType", @"'{0}' is not a member of type '{1}'");
        /// <summary>'{0}' is not a member of any type</summary>
        internal static string NotAMemberOfAnyType => GetResourceString("NotAMemberOfAnyType", @"'{0}' is not a member of any type");
        /// <summary>The expression type '{0}' is not supported</summary>
        internal static string UnsupportedExpressionType => GetResourceString("UnsupportedExpressionType", @"The expression type '{0}' is not supported");
        /// <summary>ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'</summary>
        internal static string ParameterExpressionNotValidAsDelegate => GetResourceString("ParameterExpressionNotValidAsDelegate", @"ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'");
        /// <summary>Property '{0}' is not defined for type '{1}'</summary>
        internal static string PropertyNotDefinedForType => GetResourceString("PropertyNotDefinedForType", @"Property '{0}' is not defined for type '{1}'");
        /// <summary>Instance property '{0}' is not defined for type '{1}'</summary>
        internal static string InstancePropertyNotDefinedForType => GetResourceString("InstancePropertyNotDefinedForType", @"Instance property '{0}' is not defined for type '{1}'");
        /// <summary>Instance property '{0}' that takes no argument is not defined for type '{1}'</summary>
        internal static string InstancePropertyWithoutParameterNotDefinedForType => GetResourceString("InstancePropertyWithoutParameterNotDefinedForType", @"Instance property '{0}' that takes no argument is not defined for type '{1}'");
        /// <summary>Instance property '{0}{1}' is not defined for type '{2}'</summary>
        internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType => GetResourceString("InstancePropertyWithSpecifiedParametersNotDefinedForType", @"Instance property '{0}{1}' is not defined for type '{2}'");
        /// <summary>Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'</summary>
        internal static string InstanceAndMethodTypeMismatch => GetResourceString("InstanceAndMethodTypeMismatch", @"Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'");
        /// <summary>Type {0} contains generic parameters</summary>
        internal static string TypeContainsGenericParameters => GetResourceString("TypeContainsGenericParameters", @"Type {0} contains generic parameters");
        /// <summary>Type {0} is a generic type definition</summary>
        internal static string TypeIsGeneric => GetResourceString("TypeIsGeneric", @"Type {0} is a generic type definition");
        /// <summary>Type '{0}' does not have a default constructor</summary>
        internal static string TypeMissingDefaultConstructor => GetResourceString("TypeMissingDefaultConstructor", @"Type '{0}' does not have a default constructor");
        /// <summary>Element initializer method must be named 'Add'</summary>
        internal static string ElementInitializerMethodNotAdd => GetResourceString("ElementInitializerMethodNotAdd", @"Element initializer method must be named 'Add'");
        /// <summary>Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter</summary>
        internal static string ElementInitializerMethodNoRefOutParam => GetResourceString("ElementInitializerMethodNoRefOutParam", @"Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter");
        /// <summary>Element initializer method must have at least 1 parameter</summary>
        internal static string ElementInitializerMethodWithZeroArgs => GetResourceString("ElementInitializerMethodWithZeroArgs", @"Element initializer method must have at least 1 parameter");
        /// <summary>Element initializer method must be an instance method</summary>
        internal static string ElementInitializerMethodStatic => GetResourceString("ElementInitializerMethodStatic", @"Element initializer method must be an instance method");
        /// <summary>Type '{0}' is not IEnumerable</summary>
        internal static string TypeNotIEnumerable => GetResourceString("TypeNotIEnumerable", @"Type '{0}' is not IEnumerable");
        /// <summary>Unhandled binary: {0}</summary>
        internal static string UnhandledBinary => GetResourceString("UnhandledBinary", @"Unhandled binary: {0}");
        /// <summary>Unhandled binding</summary>
        internal static string UnhandledBinding => GetResourceString("UnhandledBinding", @"Unhandled binding");
        /// <summary>Unhandled Binding Type: {0}</summary>
        internal static string UnhandledBindingType => GetResourceString("UnhandledBindingType", @"Unhandled Binding Type: {0}");
        /// <summary>Unhandled unary: {0}</summary>
        internal static string UnhandledUnary => GetResourceString("UnhandledUnary", @"Unhandled unary: {0}");
        /// <summary>Unknown binding type</summary>
        internal static string UnknownBindingType => GetResourceString("UnknownBindingType", @"Unknown binding type");
        /// <summary>The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.</summary>
        internal static string UserDefinedOpMustHaveConsistentTypes => GetResourceString("UserDefinedOpMustHaveConsistentTypes", @"The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.");
        /// <summary>The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.</summary>
        internal static string UserDefinedOpMustHaveValidReturnType => GetResourceString("UserDefinedOpMustHaveValidReturnType", @"The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.");
        /// <summary>The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.</summary>
        internal static string LogicalOperatorMustHaveBooleanOperators => GetResourceString("LogicalOperatorMustHaveBooleanOperators", @"The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.");
        /// <summary>No method '{0}' on type '{1}' is compatible with the supplied arguments.</summary>
        internal static string MethodWithArgsDoesNotExistOnType => GetResourceString("MethodWithArgsDoesNotExistOnType", @"No method '{0}' on type '{1}' is compatible with the supplied arguments.");
        /// <summary>No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic.</summary>
        internal static string GenericMethodWithArgsDoesNotExistOnType => GetResourceString("GenericMethodWithArgsDoesNotExistOnType", @"No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic.");
        /// <summary>More than one method '{0}' on type '{1}' is compatible with the supplied arguments.</summary>
        internal static string MethodWithMoreThanOneMatch => GetResourceString("MethodWithMoreThanOneMatch", @"More than one method '{0}' on type '{1}' is compatible with the supplied arguments.");
        /// <summary>More than one property '{0}' on type '{1}' is compatible with the supplied arguments.</summary>
        internal static string PropertyWithMoreThanOneMatch => GetResourceString("PropertyWithMoreThanOneMatch", @"More than one property '{0}' on type '{1}' is compatible with the supplied arguments.");
        /// <summary>An incorrect number of type arguments were specified for the declaration of a Func type.</summary>
        internal static string IncorrectNumberOfTypeArgsForFunc => GetResourceString("IncorrectNumberOfTypeArgsForFunc", @"An incorrect number of type arguments were specified for the declaration of a Func type.");
        /// <summary>An incorrect number of type arguments were specified for the declaration of an Action type.</summary>
        internal static string IncorrectNumberOfTypeArgsForAction => GetResourceString("IncorrectNumberOfTypeArgsForAction", @"An incorrect number of type arguments were specified for the declaration of an Action type.");
        /// <summary>Argument type cannot be System.Void.</summary>
        internal static string ArgumentCannotBeOfTypeVoid => GetResourceString("ArgumentCannotBeOfTypeVoid", @"Argument type cannot be System.Void.");
        /// <summary>{0} must be greater than or equal to {1}</summary>
        internal static string OutOfRange => GetResourceString("OutOfRange", @"{0} must be greater than or equal to {1}");
        /// <summary>Cannot redefine label '{0}' in an inner block.</summary>
        internal static string LabelTargetAlreadyDefined => GetResourceString("LabelTargetAlreadyDefined", @"Cannot redefine label '{0}' in an inner block.");
        /// <summary>Cannot jump to undefined label '{0}'.</summary>
        internal static string LabelTargetUndefined => GetResourceString("LabelTargetUndefined", @"Cannot jump to undefined label '{0}'.");
        /// <summary>Control cannot leave a finally block.</summary>
        internal static string ControlCannotLeaveFinally => GetResourceString("ControlCannotLeaveFinally", @"Control cannot leave a finally block.");
        /// <summary>Control cannot leave a filter test.</summary>
        internal static string ControlCannotLeaveFilterTest => GetResourceString("ControlCannotLeaveFilterTest", @"Control cannot leave a filter test.");
        /// <summary>Cannot jump to ambiguous label '{0}'.</summary>
        internal static string AmbiguousJump => GetResourceString("AmbiguousJump", @"Cannot jump to ambiguous label '{0}'.");
        /// <summary>Control cannot enter a try block.</summary>
        internal static string ControlCannotEnterTry => GetResourceString("ControlCannotEnterTry", @"Control cannot enter a try block.");
        /// <summary>Control cannot enter an expression--only statements can be jumped into.</summary>
        internal static string ControlCannotEnterExpression => GetResourceString("ControlCannotEnterExpression", @"Control cannot enter an expression--only statements can be jumped into.");
        /// <summary>Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.</summary>
        internal static string NonLocalJumpWithValue => GetResourceString("NonLocalJumpWithValue", @"Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.");
        /// <summary>CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.</summary>
        internal static string CannotCompileConstant => GetResourceString("CannotCompileConstant", @"CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.");
        /// <summary>Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.</summary>
        internal static string CannotCompileDynamic => GetResourceString("CannotCompileDynamic", @"Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.");
        /// <summary>Invalid lvalue for assignment: {0}.</summary>
        internal static string InvalidLvalue => GetResourceString("InvalidLvalue", @"Invalid lvalue for assignment: {0}.");
        /// <summary>variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined</summary>
        internal static string UndefinedVariable => GetResourceString("UndefinedVariable", @"variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined");
        /// <summary>Cannot close over byref parameter '{0}' referenced in lambda '{1}'</summary>
        internal static string CannotCloseOverByRef => GetResourceString("CannotCloseOverByRef", @"Cannot close over byref parameter '{0}' referenced in lambda '{1}'");
        /// <summary>Unexpected VarArgs call to method '{0}'</summary>
        internal static string UnexpectedVarArgsCall => GetResourceString("UnexpectedVarArgsCall", @"Unexpected VarArgs call to method '{0}'");
        /// <summary>Rethrow statement is valid only inside a Catch block.</summary>
        internal static string RethrowRequiresCatch => GetResourceString("RethrowRequiresCatch", @"Rethrow statement is valid only inside a Catch block.");
        /// <summary>Try expression is not allowed inside a filter body.</summary>
        internal static string TryNotAllowedInFilter => GetResourceString("TryNotAllowedInFilter", @"Try expression is not allowed inside a filter body.");
        /// <summary>When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.</summary>
        internal static string MustRewriteToSameNode => GetResourceString("MustRewriteToSameNode", @"When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.");
        /// <summary>Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.</summary>
        internal static string MustRewriteChildToSameType => GetResourceString("MustRewriteChildToSameType", @"Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.");
        /// <summary>Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.</summary>
        internal static string MustRewriteWithoutMethod => GetResourceString("MustRewriteWithoutMethod", @"Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.");
        /// <summary>The value null is not of type '{0}' and cannot be used in this collection.</summary>
        internal static string InvalidNullValue => GetResourceString("InvalidNullValue", @"The value null is not of type '{0}' and cannot be used in this collection.");
        /// <summary>The value '{0}' is not of type '{1}' and cannot be used in this collection.</summary>
        internal static string InvalidObjectType => GetResourceString("InvalidObjectType", @"The value '{0}' is not of type '{1}' and cannot be used in this collection.");
        /// <summary>TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.</summary>
        internal static string TryNotSupportedForMethodsWithRefArgs => GetResourceString("TryNotSupportedForMethodsWithRefArgs", @"TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.");
        /// <summary>TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.</summary>
        internal static string TryNotSupportedForValueTypeInstances => GetResourceString("TryNotSupportedForValueTypeInstances", @"TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.");
        /// <summary>Enumeration has either not started or has already finished.</summary>
        internal static string EnumerationIsDone => GetResourceString("EnumerationIsDone", @"Enumeration has either not started or has already finished.");
        /// <summary>Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'</summary>
        internal static string TestValueTypeDoesNotMatchComparisonMethodParameter => GetResourceString("TestValueTypeDoesNotMatchComparisonMethodParameter", @"Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'");
        /// <summary>Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'</summary>
        internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter => GetResourceString("SwitchValueTypeDoesNotMatchComparisonMethodParameter", @"Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'");
        /// <summary>DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.</summary>
        internal static string PdbGeneratorNeedsExpressionCompiler => GetResourceString("PdbGeneratorNeedsExpressionCompiler", @"DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.");
        /// <summary>Invalid argument value</summary>
        internal static string InvalidArgumentValue_ParamName => GetResourceString("InvalidArgumentValue_ParamName", @"Invalid argument value");
        /// <summary>Non-empty collection required</summary>
        internal static string NonEmptyCollectionRequired => GetResourceString("NonEmptyCollectionRequired", @"Non-empty collection required");
        /// <summary>Collection was modified; enumeration operation may not execute.</summary>
        internal static string CollectionModifiedWhileEnumerating => GetResourceString("CollectionModifiedWhileEnumerating", @"Collection was modified; enumeration operation may not execute.");
        /// <summary>Expression must be readable</summary>
        internal static string ExpressionMustBeReadable => GetResourceString("ExpressionMustBeReadable", @"Expression must be readable");
        /// <summary>Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'</summary>
        internal static string ExpressionTypeDoesNotMatchMethodParameter => GetResourceString("ExpressionTypeDoesNotMatchMethodParameter", @"Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'");
        /// <summary>Expression of type '{0}' cannot be used for parameter of type '{1}'</summary>
        internal static string ExpressionTypeDoesNotMatchParameter => GetResourceString("ExpressionTypeDoesNotMatchParameter", @"Expression of type '{0}' cannot be used for parameter of type '{1}'");
        /// <summary>Expression of type '{0}' cannot be used for constructor parameter of type '{1}'</summary>
        internal static string ExpressionTypeDoesNotMatchConstructorParameter => GetResourceString("ExpressionTypeDoesNotMatchConstructorParameter", @"Expression of type '{0}' cannot be used for constructor parameter of type '{1}'");
        /// <summary>Incorrect number of arguments supplied for call to method '{0}'</summary>
        internal static string IncorrectNumberOfMethodCallArguments => GetResourceString("IncorrectNumberOfMethodCallArguments", @"Incorrect number of arguments supplied for call to method '{0}'");
        /// <summary>Incorrect number of arguments supplied for lambda invocation</summary>
        internal static string IncorrectNumberOfLambdaArguments => GetResourceString("IncorrectNumberOfLambdaArguments", @"Incorrect number of arguments supplied for lambda invocation");
        /// <summary>Incorrect number of arguments for constructor</summary>
        internal static string IncorrectNumberOfConstructorArguments => GetResourceString("IncorrectNumberOfConstructorArguments", @"Incorrect number of arguments for constructor");
        /// <summary>The constructor should not be static</summary>
        internal static string NonStaticConstructorRequired => GetResourceString("NonStaticConstructorRequired", @"The constructor should not be static");
        /// <summary>Can't compile a NewExpression with a constructor declared on an abstract class</summary>
        internal static string NonAbstractConstructorRequired => GetResourceString("NonAbstractConstructorRequired", @"Can't compile a NewExpression with a constructor declared on an abstract class");
        /// <summary>First argument of delegate must be CallSite</summary>
        internal static string FirstArgumentMustBeCallSite => GetResourceString("FirstArgumentMustBeCallSite", @"First argument of delegate must be CallSite");
        /// <summary>No or Invalid rule produced</summary>
        internal static string NoOrInvalidRuleProduced => GetResourceString("NoOrInvalidRuleProduced", @"No or Invalid rule produced");
        /// <summary>Type must be derived from System.Delegate</summary>
        internal static string TypeMustBeDerivedFromSystemDelegate => GetResourceString("TypeMustBeDerivedFromSystemDelegate", @"Type must be derived from System.Delegate");
        /// <summary>Type parameter is {0}. Expected a delegate.</summary>
        internal static string TypeParameterIsNotDelegate => GetResourceString("TypeParameterIsNotDelegate", @"Type parameter is {0}. Expected a delegate.");
        /// <summary>Argument type cannot be void</summary>
        internal static string ArgumentTypeCannotBeVoid => GetResourceString("ArgumentTypeCannotBeVoid", @"Argument type cannot be void");
        /// <summary>Argument count must be greater than number of named arguments.</summary>
        internal static string ArgCntMustBeGreaterThanNameCnt => GetResourceString("ArgCntMustBeGreaterThanNameCnt", @"Argument count must be greater than number of named arguments.");
        /// <summary>The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.</summary>
        internal static string BinderNotCompatibleWithCallSite => GetResourceString("BinderNotCompatibleWithCallSite", @"The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.");
        /// <summary>Bind cannot return null.</summary>
        internal static string BindingCannotBeNull => GetResourceString("BindingCannotBeNull", @"Bind cannot return null.");
        /// <summary>The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.</summary>
        internal static string DynamicBinderResultNotAssignable => GetResourceString("DynamicBinderResultNotAssignable", @"The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.");
        /// <summary>The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.</summary>
        internal static string DynamicBindingNeedsRestrictions => GetResourceString("DynamicBindingNeedsRestrictions", @"The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.");
        /// <summary>The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.</summary>
        internal static string DynamicObjectResultNotAssignable => GetResourceString("DynamicObjectResultNotAssignable", @"The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.");
        /// <summary>An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.</summary>
        internal static string InvalidMetaObjectCreated => GetResourceString("InvalidMetaObjectCreated", @"An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.");
        /// <summary>More than one key matching '{0}' was found in the ExpandoObject.</summary>
        internal static string AmbiguousMatchInExpandoObject => GetResourceString("AmbiguousMatchInExpandoObject", @"More than one key matching '{0}' was found in the ExpandoObject.");
        /// <summary>Collection is read-only.</summary>
        internal static string CollectionReadOnly => GetResourceString("CollectionReadOnly", @"Collection is read-only.");
        /// <summary>The specified key '{0}' does not exist in the ExpandoObject.</summary>
        internal static string KeyDoesNotExistInExpando => GetResourceString("KeyDoesNotExistInExpando", @"The specified key '{0}' does not exist in the ExpandoObject.");
        /// <summary>An element with the same key '{0}' already exists in the ExpandoObject.</summary>
        internal static string SameKeyExistsInExpando => GetResourceString("SameKeyExistsInExpando", @"An element with the same key '{0}' already exists in the ExpandoObject.");
        /// <summary>The given key '{0}' was not present in the dictionary.</summary>
        internal static string Arg_KeyNotFoundWithKey => GetResourceString("Arg_KeyNotFoundWithKey", @"The given key '{0}' was not present in the dictionary.");

    }
}
